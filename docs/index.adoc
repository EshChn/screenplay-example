= Understanding Screenplay
Matt Wynne <matt@cucumber.io>
:toc: left
:source-highlighter: rouge

Once you've decided to invest in test automation, sooner or later you'll begin to realise that you need to care about the maintainability of that test automation code just as much as you do about the implementation code itself.

For acceptance tests this problem is particularly acute: driving the application from its outside edges can involve connecting to APIs, databases, web UIs etc., and this code can quickly get out of hand. Having tried several different approaches myself over the years, I've come to believe that the Screenplay pattern is the best technique we have today.

But it doesn't get the attention it deserves.

If you've never heard of Screenplay, or have heard of it but never tried it, this tutorial is for you. It will be technical, with a good deal of code. The code will be in JavaScript, but I hope you'll be able to follow it if you're familiar with coding in any other language too.

== Myths about Screenplay

First I want to start by addressing a couple of popular misconceptions about the pattern, and give you a quick view of the fundamentals, to help frame the rest of what's to come.

=== Myth #1: Screenplay is for testing screens

Many people I've talked to about Screenplay have heard the word "screen", or read the blog posts contrasting it with the page object pattern, and assumed it must be only for UI testing. That's not the case.

The folks behind the screenplay pattern love a metaphor.

The metaphor here is not about screens from the user interface of your app, no! The metaphor is that each of your scenarios is like a little stage-play, with actors performing actions.

In fact, as we'll see, the whole idea is to get away from thinking about interaction details, and focus on behaviour and intent.

In retrospect, maybe something like _Playwright_ might have made a better name for this pattern to avoid any confusion caused by conflated interpretations of the word "screen". Anyway, it's too late for that now.

So let's be totally clear. The Screenplay pattern does not have anything to say about whether you test through your UI or not. In fact, Screenplay can help free you up from this hideous bind, and give you more choices about where to connect to your app, and keep your code better organised.

=== Myth #2: Screenplay is over-complicated
I'll admit that this was my reaction at first. Even though I had a strong feeling there was something useful in this pattern, I found all the early examples I read to be quite hard to fathom, with a lot of new concepts to understand. It all made me feel a bit stupid.

Having got my head around it now, I can tell you for sure that there's a super-simple core idea here. Essentially, Screenplay is just the command pattern applied in the specific context of organising test automation code.

In fact, I bet that if you've worked on a test automation suite of any reasonable size, you'll know exactly what over-complicated feels like. Massive classes heaving with too many methods. Awkward hierarchies of objects to try and avoid duplication. A maze of different files.
This pattern is a way out of that.

If I've done my job right then, by the end of this series, you'll see that it's really not that complicated at all.

== The fundamentals of Screenplay

The fundamental element of the Screenplay pattern is an Interaction. Instead of having the code that interacts with our app littered around in helper methods or page objects, we separate and encapsulate each tiny granule of work as an individual object, each with the same interface: a single method that allows us to run that action against our app.

For example, you might have an Interaction like InsertInto which knows how to insert a record into an SQL database table. Or you might have an Interaction like WriteTo that can write to a text file on disk. Or an Interaction like FillIn which can put text into a field in a browser. Or an Interaction like PostJson that sends a payload to an API endpoint.

Then, we express the behaviour we want in our tests by creating lists of these Interaction objects that we want to execute, like:

[source,javascript]
----
attemptTo(
  new InsertInto({
    table: "Companies", 
    data: { name: "ACME" } 
  }),
  new InsertInto({
    table: "Accounts",
    data: { name: "Dave", password: "secret", company: "ACME" }
  }),
  new FillIn({
    field: "Username",
    with: "Dave"
  }),
  new FillIn({
    field: "Password",
    with: "secret"
  })
  new ClickOn({ button: "Login" })
)
----

We can create factory DSLs to make this code read better:

[source,javascript]
----
attemptTo(
  InsertInto.table("Companies").data({ name: "ACME" }),
  InsertInto.table("Accounts").data({ name: "Dave", password: "secret", company: "ACME" }),
  FillIn.field("Username").with("Dave"),
  FillIn.field("Password").with("secret"),
  ClickOn.button("Login" )
)
----

The sweet thing about breaking down our automation into these tiny pieces is that it allows us to compose these little Interactions into bigger chunks (called Tasks) that make sense in our particular problem domain:

[source, javascript]
----
attemptTo(
  CreateAccount.for("Dave").withPassword("secret"),
  Login.as("Dave").withPassword("secret")
)
----

The basic shift in thinking that you'll need to grasp in order to understand the Screenplay pattern is this: all of your automation behaviour is going to be organised into little elemental pieces instead of being in methods on helper classes.

Screenplay doesn't have to be something you can only introduce into your next greenfield project. We've successfully introduced Screenplay side-by-side with existing automation code, gradually refactoring towards it.

Over the course of this tutorial, we'll refactor take a typical Cucumber codebase and refactor it towards this pattern, extracting and develop our own little Screenplay library as we go. In doing this, you'll get a firm handle on how to apply the pattern yourself.

== What's wrong with helpers?

In the first post in this series we introduced the concept of the Screenplay pattern and busted a couple of popular myths about it. Now it's time to start digging into some code to give us a real example to demonstrate the pattern on.

The problem with writing this kind of tutorial, always, is finding the right balance between an example that's so complicated it gets in the way of your understanding the thing we're actually trying to learn about, and one that's so simplistic that the need for any kind of software design seems superfluous. If you'll forgive me, we'll err towards the simplistic here, and I'll trust that you've seen enough complex code in the wild to recognise the need for some design work.

=== Time for an example
Turn your imagination up to max and pretend we're building a web-based app that needs people to be able to sign up. This sign up feature is going to be the big differentiator to help us stand out in the market, I can feel it.

Sign-up is a two-step process, as described in this feature file:

[source,gherkin]
----
include::code/00-add-sign-up-feature/features/sign_up.feature[]
----

So far so good. We have one happy path scenario for Tanya creating then activating her account, and being able to sign in. We have another that illustrates what happens if hapless Bob tries to sign in before he's got around to activating the account.

Now let's drop down a layer and have a look at the step definitions we've written that bring these scenarios to life our JavaScript project:

[source,js]
----
include::code/00-add-sign-up-feature/features/step_definitions/steps.js[]
----

There's a couple of things going on here, so let's pick them apart.

We can see that each step definition uses the cucumber expression syntax, avoiding the need for ugly regular expressions, and instead capturing the name of the user with the built in `{word}` parameter type. Partly, I just wanted to show off this new feature, but it's also going to come in handy later.

Next, notice that each of the step definition functions is a one-liner, delegating to a method on `this`. Delegating the automation work to helper methods allows us to keep a separation of concerns between these two layers:

* Step Definitions translate from plain English in the scenarios into code.
* Helper, or driver methods actually interact with the app.

Working this way, we build up a library of re-usable driver code that does the actual leg-work of automating our app. Gradually, we develop an API (some people even call it a DSL) for driving our application from our tests.

Introducing this separation also allows us the flexibility to swap in different implementations of the driver API, when we want to connect our automation at different layers of the app. If we want to, we can have a SeleniumDriver that uses a browser (perhaps via page objects), and a DomainDriver that does the same things directly against the domain model.

But I digress.

=== Where do the helper methods live?

In cucumber-js projects, `this` in the context of a step definition function is the World, an object that is created by Cucumber for the duration of the scenario, which we can add custom methods and properties to. Ruby's flavour of Cucumber offers the same concept. In Cucumber-JVM and SpecFlow projects you have to inject your own objects that contain your helpers, but the principle is the same.

We won't dig any deeper into our automation stack right now. Let's just trust that those helper methods are there, doing what they say they do.

=== A new requirement

As they tend to do from time to time, our product owner would like this app of ours to do something new. She has an idea that our app will have projects that users with existing accounts can create. I don't know where she gets these wild ideas.
Here's the feature file:

We've introduced a handful of new steps here. Let's look at how these are defined:

This all seems quite straightforward in our simple example, but if we're really sensitive to them, we might notice a couple of issues that could cause concern as the codebase grows.

First, we have duplication of the project name, a-project. We've made the sensible choice to push this detail down out of the scenarios to make them more readable (avoiding incidental details), but we're now left with the problem of needing that information in two places in our code. One solution might be to stash the project name on the World, like this:

If you use Cucumber-Ruby you've probably done this kind of thing using an instance variable. SpecFlow or Cucumber-JVM practitioners maybe have used a ScenarioContext object. Like using helper methods, this is common practice in the Cucumber community. While this will work OK for now, what we're starting to see is that the World object is just getting more and more complicated.

It's becoming a God object.

Well-designed objects have the property of cohesion. That means the methods on that object all have a reason to be together, such as sharing the same internal state. God objects don't have this property. They're just a grab-bag of methods that have no reason to be on the same class other than for a lack of a better place to put them.

Another niggling concern is that we've broken our idiom of having one-liner step definitions. We're introduced the concept of "signing up" which rolls together the two granular actions of creating an account and then activating it.

At this stage, a two-line step definition is not a big deal, but it's the wrong direction of travel. As we build up a more rich and interesting system we'll have more and more of these abstractions. We could push this down into a signUp helper method on the world, but this doesn't actually tackle the complexity, it just pushes it away somewhere we can't see it so easily.

== Cracks are appearing

Let's take a step back for a minute and review what we do and don't like about this code so far.

On the up-side:

* The scenarios read really nicely. We're not being forced to put details into the scenarios for the sake of what's easy to code.
* We've got a good separation of concerns, with the step definitions staying simple, delegating the work of actually driving the application to helper methods.
* The language in the step definition code is consistent with the language of the Gherkin steps. For example, we see calls to signUp and activateAccount methods rather than any details about click or fillIn. There's no translation happening in the step defintions, so we can trust them.

But we're concerned that:

* we have duplication of hard-coded details like the name of the project, when we need to share implicit context (i.e. "the project") between steps.
* adding more and more helper methods onto the World means that class will just grow and grow, and it will lack cohesion.

At the moment, in this tiny example codebase, these concerns are only hairline cracks; but we know what happens as our codebase evolves: small problems turn into big problems and, before you know it, you're stuck in a codebase you hate.

== What about Page Objects?

What if we were to use page objects? Could they help us?

Certainly, having different objects to represent the sign up form, the login form, and the new project page, would avoid us lumping all our automation code into one World object. However, this doesn't stop the bloat. Page objects that model every button and interaction point on a page can become huge and unwieldy.

A more insidious problem is that page objects are based around the UI. This means there would have to be a leap in translation in our step defintions: we'd jump from a problem-domain concept like create a project to the nitty-gritty interactions with the app that will cause this action to happen. This isn't such a clean separation of concerns, and distracts us from focussing on the behaviour and intent of our users. If we're not careful, these detailed interactions can start to leak out into the Gherkin.

So now we have a sense of some of the problems with the typical approaches to organising acceptance test automation code.

In the next post we'll have a look at what Screenplay could offer us to solve these problems, and start using it in our example application.
